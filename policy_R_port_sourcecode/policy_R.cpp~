#include "policy.h"
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <queue>

#define DEFAULT_FILENAME "learn_result_"
#define DEFAULT_EXT      ".txt"

void save_tree_levelorder(policy *policy, std::string filename);

int main(int argc, char** argv)
{
  // Arguments: feature file path, reward file path, start number, stop number
  if (argc < 5)
    {
      std::cout << "Lacking Arguments." << std::endl;
      return -1;
    }

  int start_idx = std::atoi(argv[3]);
  int end_idx = std::atoi(argv[4]);

  if (end_idx < start_idx)
    {
      std::cout << "Wrong Test Index Range" << std::endl;
      return -2;
    }

  for (unsigned int m = start_idx; m <= end_idx; m++)
    {
      // Reading filename from arguments
      std::string feature_filename(argv[1]);
      std::string reward_filename(argv[2]);
      std::string index = std::to_string(m);
      std::string ext_name(".txt");
      
      std::string feature_path = feature_filename + index + ext_name;
      std::string reward_path = reward_filename + index + ext_name;

      // Create ifstreams for opening files.
      std::ifstream feature_file;
      std::ifstream reward_file;

      std::cout << "Opening Feature and Reward file No. " << m << std::endl;

      // Open files
      feature_file.open(feature_path);
      if (!feature_file.good())
	{
	  std::cout << "Open feature file No. " << m << " failed." << std::endl;
	  return -3;
	}
      reward_file.open(reward_path);
      if (!reward_file.good())
	{
	  std::cout << "Open reward file No. " << m << " failed." << std::endl;
	  return -3;
	}

      std::cout << "Open Feature and Reward file No. " << m << " success." << std::endl;


      // Read n, p, k, l
      int n, p, k, l;
      feature_file >> n;
      feature_file >> p;
      feature_file >> k;
      feature_file >> l;

      // Allocate memory for test_feature and reward
      double **test_feature = NULL;
      double **test_reward = NULL;

      test_feature = new double*[n];
      test_reward = new double*[n];

      for (unsigned int i = 0; i < n; i++)
	{
	  test_feature[i] = new double[p];
	  test_reward[i] = new double[k];
	}

      // Read data from feature and reward files.
      double temp = 0.0;
      for (unsigned int i = 0; i < n; i++)
	{
	  for (unsigned int j = 0; j < p; j++)
	    {
	      feature_file >> temp;
	      test_feature[i][j] = temp;
	    }
	}

      for (unsigned int i = 0; i < n; i++)
	{
	  for (unsigned int j = 0; j < k; j++)
	    {
	      reward_file >> temp;
	      test_reward[i][j] = temp;
	    }
	}

      // Close files
      feature_file.close();
      reward_file.close();


      // Calculate and save tree to text files
      policy *test_policy = new policy(n, p, k, 1, test_feature, test_reward, l);
      test_policy->learn_from_data(test_policy->root);
      save_tree_levelorder(test_policy, std::string(DEFAULT_FILENAME) + std::to_string(m) + std::string(DEFAULT_EXT));
      std::cout << "For test " << m << " Reward is " << (test_policy->root)->subtree_reward << std::endl;
      delete(test_policy);
      test_policy = NULL;
    }

  return 0;
}

void save_tree_levelorder(policy *policy, std::string filename)
{
  std::ofstream out_file(filename);

  // Level-Order Traversal
  std::queue<treenode *> tree_queue;
  tree_queue.push(policy->root);

  while (!tree_queue.empty())
    {
      treenode *node = tree_queue.front();
      tree_queue.pop();

      out_file << node->id << " " << node->subtree_reward << " " << node->data.first << " " << node->data.second << std::endl;

      if (node->left != NULL)
	{
	  tree_queue.push(node->left);
	}
      if (node->right != NULL)
	{
	  tree_queue.push(node->right);
	}
    }
}
